<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 圖片文字移除 PRO - Canvas 版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); min-height: 100vh; }
        .drop-zone-active { border-color: #3b82f6 !important; background-color: rgba(59, 130, 246, 0.1) !important; transform: scale(1.02); }
        .loader { border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid #3b82f6; border-radius: 50%; width: 20px; height: 20px; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .glass { background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
        .result-card { transition: all 0.3s ease; }
        .result-card:hover { transform: translateY(-4px); box-shadow: 0 20px 40px rgba(0,0,0,0.3); }
        .progress-bar { transition: width 0.3s ease; }
        .custom-scrollbar::-webkit-scrollbar { height: 6px; width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }

        /* Checkbox Custom Style */
        .custom-checkbox:checked + div {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.2);
        }
        .custom-checkbox:checked + div .check-icon {
            opacity: 1;
            transform: scale(1);
        }
    </style>
</head>
<body class="text-white pb-20">
    <div class="max-w-6xl mx-auto px-4 py-12">
        <!-- 標題 -->
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-3">
                AI 圖片文字移除 <span class="text-blue-400">PRO</span> <span class="text-xs align-top bg-emerald-600/30 text-emerald-400 px-2 py-1 rounded-md ml-2 border border-emerald-500/30">Canvas</span>
            </h1>
            <p class="text-slate-400 text-lg">上傳 PDF 或圖片 → 選擇頁面 → 自動去字 → 導出雙 PPTX</p>
            <div class="flex items-center justify-center gap-4 mt-4">
                <span class="flex items-center gap-2 text-xs text-blue-400">
                    <span class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></span>
                    Powered by Gemini 2.5
                </span>
            </div>
        </header>

        <!-- 主上傳區 -->
        <section id="upload-section" class="mb-10 transition-all duration-300">
            <div id="drop-zone" class="glass rounded-3xl p-16 text-center cursor-pointer hover:border-blue-500/50 transition-all duration-300 group">
                <input type="file" id="file-input" class="hidden" accept="application/pdf,image/*" multiple>
                <div class="w-20 h-20 bg-blue-500/20 text-blue-400 rounded-2xl flex items-center justify-center mx-auto mb-6 group-hover:scale-110 transition-transform">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                </div>
                <p class="text-2xl font-bold text-white mb-2">拖放 PDF 或圖片</p>
                <p class="text-slate-400">點擊此處選擇檔案</p>
                <div id="lib-warning" class="mt-4 text-xs text-amber-400 hidden">警告：組件尚未就緒，請稍候...</div>
            </div>
        </section>

        <!-- 選擇頁面區 -->
        <section id="selection-section" class="hidden mb-10 animate-fade-in">
            <div class="flex items-center justify-between mb-6 flex-wrap gap-4">
                <div>
                    <h2 class="text-2xl font-bold flex items-center gap-2">
                        <span class="bg-blue-500 w-8 h-8 rounded-full flex items-center justify-center text-sm">1</span>
                        選擇要處理的頁面
                    </h2>
                    <p class="text-slate-400 text-sm mt-1 ml-10">僅勾選需要的頁面以節省時間</p>
                </div>
                <div class="flex gap-3">
                    <button id="select-all-btn" class="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600 text-sm font-bold transition">全選</button>
                    <button id="deselect-all-btn" class="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600 text-sm font-bold transition">全取消</button>
                    <button id="start-process-btn" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-2 rounded-xl text-sm font-bold shadow-lg shadow-blue-500/20 transition flex items-center gap-2">
                        開始處理 (<span id="selected-count">0</span>)
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
                        </svg>
                    </button>
                </div>
            </div>

            <div id="selection-grid" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-4 custom-scrollbar max-h-[60vh] overflow-y-auto p-2">
                <!-- 縮圖將生成於此 -->
            </div>
        </section>

        <!-- 處理進度區 -->
        <section id="progress-section" class="hidden mb-10">
            <div class="glass rounded-3xl p-8">
                <div class="flex items-center justify-between mb-6">
                    <div class="flex items-center gap-4">
                        <div class="loader"></div>
                        <div>
                            <p id="progress-title" class="font-bold text-lg">處理中...</p>
                            <p id="progress-detail" class="text-sm text-slate-400">分析中</p>
                        </div>
                    </div>
                    <span id="progress-count" class="text-2xl font-black text-blue-400">0/0</span>
                </div>
                <div class="w-full bg-slate-700 rounded-full h-2 overflow-hidden">
                    <div id="progress-bar" class="progress-bar bg-gradient-to-r from-blue-500 to-purple-500 h-full rounded-full" style="width: 0%"></div>
                </div>
            </div>
        </section>

        <!-- 結果區 -->
        <section id="results-section" class="hidden">
            <div class="flex items-center justify-between mb-6 flex-wrap gap-4 border-t border-slate-700 pt-8">
                <div>
                    <h2 class="text-2xl font-bold flex items-center gap-2">
                        <span class="bg-emerald-500 w-8 h-8 rounded-full flex items-center justify-center text-sm">2</span>
                        處理結果
                    </h2>
                </div>
                <div class="flex items-center gap-3 flex-wrap">
                    <select id="ratio-select" class="bg-slate-800 border border-slate-700 rounded-xl px-4 py-2 text-sm font-bold outline-none">
                        <option value="16:9">16:9 橫式</option>
                        <option value="9:16">9:16 直式</option>
                        <option value="4:3">4:3 標準</option>
                    </select>
                    <button id="export-combined-btn" class="bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white px-5 py-2.5 rounded-xl font-bold shadow-lg transition flex items-center gap-2">
                        合併 PPTX ⭐
                    </button>
                    <button id="reset-btn" class="bg-red-600/20 hover:bg-red-600/30 text-red-400 px-4 py-2.5 rounded-xl font-bold transition">重新開始</button>
                </div>
            </div>
            <div id="results-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 custom-scrollbar"></div>
        </section>
    </div>

    <div id="toast" class="fixed bottom-8 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-2xl shadow-2xl opacity-0 transition-all pointer-events-none z-50 text-sm font-bold border border-slate-700"></div>

    <script>
        const apiKey = "";

        const MODEL_IMAGE_EDIT = "gemini-2.5-flash-image-preview";
        const MODEL_TEXT_GEN = "gemini-2.5-flash-preview-09-2025";

        // 狀態管理
        let pendingItems = [];
        let results = [];

        function initPdfLibrary() {
            try {
                if (window.pdfjsLib) {
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    return true;
                }
            } catch (e) { console.error(e); }
            document.getElementById('lib-warning').classList.remove('hidden');
            return false;
        }

        // UI 元素
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const uploadSection = document.getElementById('upload-section');
        const selectionSection = document.getElementById('selection-section');
        const selectionGrid = document.getElementById('selection-grid');
        const progressSection = document.getElementById('progress-section');
        const resultsSection = document.getElementById('results-section');
        const progressBar = document.getElementById('progress-bar');
        const progressTitle = document.getElementById('progress-title');
        const progressDetail = document.getElementById('progress-detail');
        const progressCount = document.getElementById('progress-count');
        const resultsGrid = document.getElementById('results-grid');
        const toast = document.getElementById('toast');
        const selectedCountSpan = document.getElementById('selected-count');

        // 初始化檢查 (Window Load)
        window.onload = () => {
            initPdfLibrary();
        };

        function showToast(msg, isError = false) {
            toast.textContent = msg;
            toast.style.backgroundColor = isError ? '#ef4444' : '#1e293b';
            toast.classList.replace('opacity-0', 'opacity-100');
            setTimeout(() => toast.classList.replace('opacity-100', 'opacity-0'), 3000);
        }

        const wait = (ms) => new Promise(res => setTimeout(res, ms));

        // PDF.js 直接提取文字資訊（比 OCR 更準確）
        async function extractTextFromPdf(page, scale = 2.0) {
            const viewport = page.getViewport({ scale });
            const textContent = await page.getTextContent();
            const pageWidth = viewport.width;
            const pageHeight = viewport.height;

            const textBlocks = textContent.items
                .map(item => {
                    const [scaleX, skewX] = item.transform;
                    const tx = item.transform[4] * scale;
                    const ty = item.transform[5] * scale;
                    const fontSize = Math.sqrt(scaleX * scaleX + skewX * skewX) * scale;

                    // PDF 座標系 y 軸從底部開始，需要轉換
                    const x = tx;
                    const y = pageHeight - ty;
                    const height = fontSize * 1.2;

                    // 估算文字寬度（PDF.js 可能返回 0 或 undefined）
                    const rawWidth = item.width || 0;
                    const estimatedWidth = fontSize * item.str.length * 0.6;
                    const width = (rawWidth > 0 ? rawWidth : estimatedWidth) * scale;

                    return {
                        text: item.str,
                        x,
                        y: y - height,
                        width,
                        height,
                        fontSize,
                        fontName: item.fontName || ''
                    };
                })
                .filter(block => block.text.trim().length > 0);

            return {
                blocks: mergeTextBlocks(textBlocks, pageWidth, pageHeight),
                pageWidth,
                pageHeight
            };
        }

        // 合併相鄰的文字區塊（同一行的文字）
        function mergeTextBlocks(blocks) {
            const validBlocks = (blocks || []).filter(b =>
                b && b.text && b.text.trim() && isFinite(b.x) && isFinite(b.y)
            );
            if (validBlocks.length === 0) return [];

            const avgFontSize = validBlocks.reduce((sum, b) => sum + (b.fontSize || 12), 0) / validBlocks.length;

            function getFontSize(block) {
                return block.fontSize || avgFontSize;
            }

            function estimateWidth(block) {
                return block.width || getFontSize(block) * block.text.length * 0.6;
            }

            // 步驟 1: 按 y 座標分組（使用字體大小的 80% 作為容差）
            const lines = [];
            const sortedBlocks = [...validBlocks].sort((a, b) => a.y - b.y);

            for (const block of sortedBlocks) {
                let bestLine = null;
                let minDiff = Infinity;

                for (const line of lines) {
                    const lineAvgY = line.items.reduce((sum, item) => sum + item.y, 0) / line.items.length;
                    const lineFontSize = line.items.reduce((sum, item) => sum + getFontSize(item), 0) / line.items.length;
                    const tolerance = Math.max(lineFontSize, getFontSize(block)) * 0.8;
                    const diff = Math.abs(lineAvgY - block.y);

                    if (diff < tolerance && diff < minDiff) {
                        minDiff = diff;
                        bestLine = line;
                    }
                }

                if (bestLine) {
                    bestLine.items.push(block);
                } else {
                    lines.push({ items: [block] });
                }
            }

            // 步驟 2: 每行內按 x 座標排序並合併相鄰文字
            const merged = [];

            for (const line of lines) {
                line.items.sort((a, b) => a.x - b.x);
                const lineAvgY = line.items.reduce((sum, item) => sum + item.y, 0) / line.items.length;

                let current = null;

                for (const item of line.items) {
                    const itemWidth = estimateWidth(item);

                    if (!current) {
                        current = { ...item, width: itemWidth };
                        continue;
                    }

                    const currentWidth = current.width || avgFontSize;
                    const gap = item.x - (current.x + currentWidth);
                    const gapTolerance = Math.max(getFontSize(current), getFontSize(item)) * 1.5;

                    if (Math.abs(gap) < gapTolerance) {
                        // 合併文字
                        current.text += item.text;
                        current.width = Math.max((item.x + itemWidth) - current.x, currentWidth);
                        current.height = Math.max(current.height || 0, item.height || 0);
                        current.fontSize = Math.max(current.fontSize || 0, item.fontSize || 0);
                    } else {
                        // 間距太大，視為新區塊
                        merged.push(current);
                        current = { ...item, width: itemWidth };
                    }
                }

                if (current) {
                    current.y = lineAvgY;
                    merged.push(current);
                }
            }

            return merged.sort((a, b) => a.y - b.y);
        }

        async function fetchWithRetry(url, options, maxRetries = 5) {
            const delays = [2000, 4000, 8000, 16000, 32000];
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    const data = await response.json();

                    if (response.ok) return data;

                    if (response.status === 429) {
                        const waitTime = delays[i] || 10000;
                        showToast(`API 頻率限制 (429)，等待 ${waitTime/1000} 秒後重試...`, true);
                        await wait(waitTime);
                        continue;
                    }

                    throw new Error(data.error?.message || `HTTP ${response.status}`);
                } catch (e) {
                    if (i === maxRetries - 1) throw e;
                    await wait(2000);
                }
            }
        }

        // 拖放事件
        dropZone.onclick = () => fileInput.click();
        fileInput.onchange = e => handleFiles(e.target.files);
        dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('drop-zone-active'); };
        dropZone.ondragleave = () => dropZone.classList.remove('drop-zone-active');
        dropZone.ondrop = (e) => {
            e.preventDefault();
            dropZone.classList.remove('drop-zone-active');
            handleFiles(e.dataTransfer.files);
        };

        // 步驟 1: 讀取檔案並生成縮圖
        async function handleFiles(files) {
            if (!initPdfLibrary()) return;
            if (!files || files.length === 0) return;

            // 顯示讀取中狀態
            dropZone.innerHTML = `<div class="loader mx-auto mb-4"></div><p class="text-slate-300">正在讀取並建立縮圖...</p>`;
            dropZone.style.pointerEvents = 'none';

            pendingItems = []; // 重置待處理清單

            try {
                for (let file of files) {
                    const isPdf = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');
                    const isImage = file.type.startsWith('image/') || /\.(jpg|jpeg|png|webp|bmp)$/i.test(file.name);

                    if (isPdf) {
                        await loadPdfAndGenerateThumbs(file);
                    } else if (isImage) {
                        const base64 = await fileToBase64(file);
                        pendingItems.push({
                            id: `img_${Date.now()}_${Math.random()}`,
                            type: 'image',
                            name: file.name,
                            thumb: base64, // 圖片直接用原圖當縮圖
                            original: base64,
                            selected: true // 預設選中
                        });
                    }
                }

                if (pendingItems.length > 0) {
                    renderSelectionGrid();
                } else {
                    showToast('不支援的檔案格式', true);
                    location.reload();
                }
            } catch (err) {
                console.error(err);
                showToast(err.message || '檔案讀取失敗', true);
                setTimeout(() => location.reload(), 2000);
            }
        }

        // 讀取 PDF 並產生低解析縮圖
        async function loadPdfAndGenerateThumbs(file) {
            const arrayBuffer = await file.arrayBuffer();
            const lib = window.pdfjsLib;

            const pdfDoc = await lib.getDocument({
                data: arrayBuffer,
                cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                cMapPacked: true
            }).promise;

            const total = pdfDoc.numPages;

            for (let i = 1; i <= total; i++) {
                const page = await pdfDoc.getPage(i);
                // 使用低 Scale (0.5) 快速生成縮圖
                const viewport = page.getViewport({ scale: 0.5 });
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: ctx, viewport }).promise;

                pendingItems.push({
                    id: `pdf_${file.name}_${i}`,
                    type: 'pdf',
                    name: `${file.name} - P${i}`,
                    thumb: canvas.toDataURL('image/jpeg', 0.6).split(',')[1],
                    pdfDoc: pdfDoc, // 保存文檔引用以便稍後高清渲染
                    pageNum: i,
                    selected: true // 預設選中
                });
            }
        }

        // 步驟 2: 渲染選擇介面
        function renderSelectionGrid() {
            uploadSection.classList.add('hidden');
            selectionSection.classList.remove('hidden');
            selectionGrid.innerHTML = '';

            pendingItems.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'relative group';
                div.innerHTML = `
                    <label class="cursor-pointer block relative">
                        <input type="checkbox" class="custom-checkbox hidden" ${item.selected ? 'checked' : ''} onchange="toggleSelection(${index}, this.checked)">
                        <div class="glass rounded-xl overflow-hidden border-2 border-transparent transition-all h-32 md:h-40 flex flex-col relative">
                            <img src="data:image/jpeg;base64,${item.thumb}" class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition">

                            <!-- 勾選狀態遮罩 -->
                            <div class="check-icon absolute top-2 right-2 w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center text-white shadow-lg transform scale-0 transition-transform duration-200">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7" /></svg>
                            </div>

                            <div class="absolute bottom-0 left-0 right-0 bg-black/60 p-1 text-[10px] text-center truncate text-white backdrop-blur-sm">
                                ${item.name}
                            </div>
                        </div>
                    </label>
                `;
                selectionGrid.appendChild(div);
            });
            updateSelectedCount();
        }

        window.toggleSelection = (index, isChecked) => {
            pendingItems[index].selected = isChecked;
            updateSelectedCount();
        };

        function updateSelectedCount() {
            const count = pendingItems.filter(i => i.selected).length;
            selectedCountSpan.textContent = count;
            document.getElementById('start-process-btn').disabled = count === 0;
            document.getElementById('start-process-btn').classList.toggle('opacity-50', count === 0);
        }

        // 全選/全取消
        document.getElementById('select-all-btn').onclick = () => {
            pendingItems.forEach(i => i.selected = true);
            renderSelectionGrid();
        };
        document.getElementById('deselect-all-btn').onclick = () => {
            pendingItems.forEach(i => i.selected = false);
            renderSelectionGrid();
        };

        // 步驟 3: 開始處理選中的項目
        document.getElementById('start-process-btn').onclick = async () => {
            const selectedItems = pendingItems.filter(i => i.selected);
            if (selectedItems.length === 0) return;

            selectionSection.classList.add('hidden');
            progressSection.classList.remove('hidden');
            resultsSection.classList.add('hidden');

            // 開始處理流程
            await processSelectedItems(selectedItems);
        };

        async function processSelectedItems(items) {
            results = [];
            resultsGrid.innerHTML = '';
            resultsSection.classList.remove('hidden');

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                let processBase64 = item.thumb; // 預設

                progressTitle.textContent = `處理中: ${item.name}`;
                progressCount.textContent = `${i + 1}/${items.length}`;
                progressBar.style.width = `${((i + 1) / items.length) * 100}%`;

                // 如果是 PDF，這裡才進行高清渲染 (Scale 2.0) 並提取原始文字
                let pdfTextData = null;
                if (item.type === 'pdf') {
                    progressDetail.textContent = "正在生成高解析影像...";
                    try {
                        const page = await item.pdfDoc.getPage(item.pageNum);
                        const viewport = page.getViewport({ scale: 2.0 }); // 高解析度
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        await page.render({ canvasContext: ctx, viewport }).promise;
                        processBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];

                        // 提取 PDF 原始文字資訊（比 OCR 更準確）
                        progressDetail.textContent = "正在提取原始文字座標...";
                        pdfTextData = await extractTextFromPdf(page, 2.0);
                    } catch (e) {
                        console.error("Re-render error", e);
                        // 若失敗則降級使用縮圖
                    }
                } else {
                    processBase64 = item.original;
                }

                progressDetail.textContent = "AI 正在移除文字並重建背景...";

                try {
                    const cleaned = await removeTextWithGemini(processBase64);
                    results.push({
                        name: item.name,
                        original: processBase64,
                        cleaned,
                        sourceType: item.type, // 'pdf' 或 'image'
                        pdfTextData: pdfTextData // PDF 來源的精確文字資訊（圖片為 null）
                    });
                    addResultCard(i, item.name, cleaned);
                } catch (e) {
                    console.error(e);
                    const isAuthError = e.message.includes("400") || e.message.includes("403") || e.message.includes("key");
                    const errMsg = isAuthError ? "API Key 無效或環境異常" : e.message;
                    results.push({
                        name: item.name,
                        original: processBase64,
                        cleaned: null,
                        error: errMsg,
                        sourceType: item.type,
                        pdfTextData: pdfTextData
                    });
                    addResultCard(i, item.name, null, errMsg);
                }

                if (i < items.length - 1) await wait(3500);
            }
            setTimeout(() => progressSection.classList.add('hidden'), 1000);
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function removeTextWithGemini(base64) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_IMAGE_EDIT}:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{
                    parts: [
                        { text: "Erase ALL text completely. Zero readable characters remaining. Inpaint background. Return only image." },
                        { inlineData: { mimeType: "image/png", data: base64 } }
                    ]
                }],
                generationConfig: { responseModalities: ['IMAGE'] }
            };

            const data = await fetchWithRetry(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const part = data.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
            if (!part) throw new Error(data.error?.message || "API 未返回影像數據");
            return part.inlineData.data;
        }

        async function ocrWithGemini(base64) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_TEXT_GEN}:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{
                    parts: [
                        {
                            text: `Analyze this image and extract all text blocks with precise positioning and styling.
For each text block, provide:
- text: the exact text content
- box_2d: bounding box as [ymin, xmin, ymax, xmax] in 0-1000 coordinate system
- font_size_pt: estimated font size in points (typical range: 8-72)
- font_weight: "normal" or "bold"
- font_style: "normal" or "italic"
- text_align: "left", "center", or "right" (based on text position in its container)
- color: hex color code like "000000" or "FFFFFF"
- line_height: line height multiplier (typically 1.0-2.0)

Return as JSON array. Be precise with bounding boxes.`
                        },
                        { inlineData: { mimeType: "image/png", data: base64 } }
                    ]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                text: { type: "STRING" },
                                box_2d: { type: "ARRAY", items: { type: "NUMBER" }, minItems: 4, maxItems: 4 },
                                font_size_pt: { type: "NUMBER" },
                                font_weight: { type: "STRING" },
                                font_style: { type: "STRING" },
                                text_align: { type: "STRING" },
                                color: { type: "STRING" },
                                line_height: { type: "NUMBER" }
                            }
                        }
                    }
                }
            };

            const data = await fetchWithRetry(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error("OCR 辨識失敗或無文字內容");
            }

            return JSON.parse(data.candidates[0].content.parts[0].text);
        }

        function addResultCard(index, name, cleaned, error) {
            const div = document.createElement('div');
            div.className = 'result-card glass rounded-2xl overflow-hidden';
            if (cleaned) {
                div.innerHTML = `
                    <img src="data:image/png;base64,${cleaned}" class="w-full aspect-video object-cover">
                    <div class="p-4 flex justify-between items-center text-[10px]">
                        <span class="truncate max-w-[80%]">${name}</span>
                        <span class="text-emerald-400 font-bold">成功</span>
                    </div>
                `;
            } else {
                div.innerHTML = `<div class="p-6 text-center text-red-400 text-[10px]">${error || '失敗'}</div>`;
            }
            resultsGrid.appendChild(div);
        }

        document.getElementById('export-combined-btn').onclick = async () => {
            const valid = results.filter(r => r.cleaned);
            if (!valid.length) return;

            const btn = document.getElementById('export-combined-btn');
            btn.disabled = true;
            btn.innerHTML = "正在處理文字...";

            try {
                const pptx = new PptxGenJS();
                const ratio = document.getElementById('ratio-select').value;
                pptx.layout = ratio === '16:9' ? 'LAYOUT_WIDE' : ratio === '4:3' ? 'LAYOUT_4x3' : 'LAYOUT_WIDE';

                // 取得簡報實際尺寸（英吋）
                const slideWidth = ratio === '16:9' ? 13.333 : ratio === '4:3' ? 10 : 13.333;
                const slideHeight = ratio === '16:9' ? 7.5 : ratio === '4:3' ? 7.5 : 7.5;

                for (let i = 0; i < valid.length; i++) {
                    const r = valid[i];
                    const slide = pptx.addSlide();
                    slide.addImage({ data: `data:image/png;base64,${r.cleaned}`, x: 0, y: 0, w: '100%', h: '100%' });

                    try {
                        // 根據來源類型選擇文字提取方式
                        if (r.sourceType === 'pdf' && r.pdfTextData && r.pdfTextData.blocks.length > 0) {
                            // PDF 來源：使用已提取的精確文字資訊（無需 API 調用）
                            showToast(`使用 PDF 原始文字 (${i+1}/${valid.length})...`);

                            const { blocks, pageWidth, pageHeight } = r.pdfTextData;
                            blocks.forEach(block => {
                                if (!block.text.trim()) return;

                                // 將像素座標轉換為簡報百分比座標
                                const xPercent = (block.x / pageWidth) * 100;
                                const yPercent = (block.y / pageHeight) * 100;
                                const wPercent = (block.width / pageWidth) * 100;
                                const hPercent = (block.height / pageHeight) * 100;

                                // 根據簡報尺寸計算字體大小（pt）
                                // PDF 字體大小是相對於 2.0 scale，需要轉換為簡報實際大小
                                const scaleFactor = (slideHeight * 72) / pageHeight; // 72 pt per inch
                                const fontSize = Math.max(6, Math.min(72, block.fontSize * scaleFactor * 0.8));

                                slide.addText(block.text, {
                                    x: `${xPercent}%`,
                                    y: `${yPercent}%`,
                                    w: `${Math.max(wPercent, 5)}%`,
                                    h: `${Math.max(hPercent, 2)}%`,
                                    fontSize: Math.round(fontSize),
                                    color: '000000',
                                    fontFace: 'Microsoft JhengHei',
                                    valign: 'top'
                                });
                            });
                        } else {
                            // 圖片來源：使用增強版 Gemini OCR
                            showToast(`AI 辨識文字中 (${i+1}/${valid.length})...`);

                            const blocks = await ocrWithGemini(r.original);
                            blocks.forEach(b => {
                                if (!b.text || !b.text.trim()) return;

                                const [ymin, xmin, ymax, xmax] = b.box_2d;

                                // 構建文字樣式
                                const textOptions = {
                                    x: `${xmin/10}%`,
                                    y: `${ymin/10}%`,
                                    w: `${Math.max((xmax-xmin)/10, 5)}%`,
                                    h: `${Math.max((ymax-ymin)/10, 2)}%`,
                                    fontSize: b.font_size_pt || 14,
                                    color: (b.color || "000000").replace("#", ""),
                                    fontFace: 'Microsoft JhengHei',
                                    valign: 'top'
                                };

                                // 套用字重
                                if (b.font_weight === 'bold') {
                                    textOptions.bold = true;
                                }

                                // 套用斜體
                                if (b.font_style === 'italic') {
                                    textOptions.italic = true;
                                }

                                // 套用對齊
                                if (b.text_align) {
                                    textOptions.align = b.text_align;
                                }

                                slide.addText(b.text, textOptions);
                            });

                            // 圖片來源需要等待 API 冷卻
                            if (i < valid.length - 1) await wait(3500);
                        }
                    } catch (e) {
                        console.warn("Text extraction failed for slide", i, e);
                    }
                }
                pptx.writeFile({ fileName: `Result_${Date.now()}.pptx` });
                showToast('導出成功');
            } catch (e) {
                console.error("Export error", e);
                showToast("導出失敗: " + e.message, true);
            }
            btn.disabled = false;
            btn.innerHTML = "合併 PPTX ⭐";
        };

        document.getElementById('reset-btn').onclick = () => location.reload();
    </script>
</body>
</html>